<!--
/* page_FileToMem.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 2.00
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2015 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> FileToMem</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>FileToMem</h2>

<p class="Files">Files <b>CCore/inc/FileToMem.h</b> <b>CCore/src/FileToMem.cpp</b></p>

<h4>FileToMem</h4>

<p>
The class <b>FileToMem</b> loads the file to the memory. It is derived from the class 
<a href="page_ToMemBase.html"><b>ToMemBase</b></a>.
</p>

<pre>

class <span class="Att">FileToMem</span> : public ToMemBase
 {
  public:

   FileToMem() noexcept;

   explicit FileToMem(StrLen file_name,ulen max_len=MaxULen);

   ~FileToMem();
   
   // std move

   FileToMem(FileToMem &amp;&amp;obj) noexcept = default ;

   FileToMem &amp; operator = (FileToMem &amp;&amp;obj) noexcept = default ;

   // swap/move objects
   
   void objSwap(FileToMem &amp;obj);
   
   explicit FileToMem(ToMoveCtor&lt;FileToMem&gt; obj);
 };

</pre>

<p>
The first argument of the constructor is the <b>file_name</b>. The second <b>max_len</b> is a length limit.
</p>

<p>
<b>ToMemBase</b> is std movable. The original object is nullified during the move.
</p>

<p>
This class is swappable and movable.
</p>

<h4>PartFileToMem</h4>

<p>
<b>PartFileToMem</b> can be used to load parts of a file into a memory buffer. This class loads file parts sequentially.
</p>

<pre>

class <span class="Att">PartFileToMem</span> : NoCopy
 {
   RawFileToRead file;
   SimpleArray&lt;uint8&gt; buf;
   FilePosType off;
   FilePosType file_len;

  public:

   static constexpr ulen DefaultBufLen = 64_KByte ;

   explicit PartFileToMem(StrLen file_name,ulen buf_len=DefaultBufLen);

   ~PartFileToMem();

   FilePosType getFileLen() const { return file_len; }

   FilePosType getCurPos() const { return off; }

   FilePosType getRestLen() const { return file_len-off; }

   bool more() const { return off&lt;file_len; }

   PtrLen&lt;const uint8&gt; read();
 };

</pre>

<p>
Constructor has two arguments: the file name and the internal buffer length.
</p>

<p>
<b>getFileLen()</b> returns the file length.
</p>

<p>
<b>getCurPos()</b> returns the current position.
</p>

<p>
<b>getRestLen()</b> returns the length of the file part after the current position.
</p>

<p>
<b>more()</b> returns <b>true</b>, iff there is a room after the current position.
</p>

<p>
<b>read()</b> reads the next file part from the current position up to the end of the buffer or up to the end of the file.
The part is stored in the internal buffer and the constant range of bytes is returned.
</p>

</body>

</html>

